# Анализ использования pgcrypto для шифрования данных

Использование расширения `pgcrypto` в PostgreSQL для шифрования данных оказывает значительное влияние на безопасность. В данном случае шифруется пароль пользователя, что обеспечивает несколько важных уровней защиты.

## 1. Шифрование паролей

В данном примере используется симметричное шифрование с функцией `pgp_sym_encrypt` для хранения паролей. Это повышает безопасность по сравнению с хранением паролей в открытом виде, даже если злоумышленник получит доступ к базе данных.

```
 username  |                                                                          hashed_password                                                                           
-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 test_user | \xc30d040703023999a080048be39e7fd23f01539ac0422ad829ec01b54a5f1b250f44de05be453ebb8480e520d41216da3dd7d023cdb245c46b7a731e6a4fb7efc6db2cbd6b4352d1bd5832d756c4cbc6
(1 row)

 username  | pgp_sym_decrypt 
-----------+-----------------
 test_user | securepassword
(1 row)
```

### Преимущества:
- **Защита данных**: Пароли не хранятся в открытом виде, что значительно снижает риск их утечек.
- **Конфиденциальность**: Даже если база данных скомпрометирована, пароли остаются защищены, так как для их расшифровки необходим ключ шифрования.

### Ограничения:
- **Управление ключами**: Ключ шифрования должен быть надежно защищен. Если он будет скомпрометирован, все данные, зашифрованные с использованием этого ключа, могут быть расшифрованы.
- **Риски утечек**: Если ключ будет доступен злоумышленникам, это может привести к утечке данных.

## 2. Симметричное шифрование

Используемое в примере симметричное шифрование с фиксированным ключом (например, `'encryption_key'`) означает, что тот же ключ используется как для шифрования, так и для расшифровки данных.

### Преимущества:
- **Простота использования**: Симметричное шифрование — это простая и эффективная форма защиты данных.

### Ограничения:
- **Уязвимость при компрометации ключа**: Если ключ шифрования будет раскрыт или скомпрометирован, злоумышленники смогут расшифровать все данные, зашифрованные этим ключом.
- **Риски хранения ключей**: Ключи шифрования должны быть храниться в защищенных хранилищах и подлежать регулярной ротации.

### Сравнение pg_bigm и pg_trgm
```
                                                        QUERY PLAN
------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on products  (cost=832.39..1024.94 rows=50 width=242) (actual time=82.171..82.172 rows=0 loops=1)
   Recheck Cond: ((name)::text ~~ '%Adaptive zero administration conglomeration%'::text)
   ->  Bitmap Index Scan on trgm_idx_products_name  (cost=0.00..832.38 rows=50 width=0) (actual time=82.169..82.169 rows=0 loops=1)
         Index Cond: ((name)::text ~~ '%Adaptive zero administration conglomeration%'::text)
 Planning Time: 1.582 ms
 Execution Time: 82.190 ms
(6 rows)
```

```
QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on products  (cost=1168.39..1360.94 rows=50 width=242) (actual time=28.265..28.266 rows=0 loops=1)
   Recheck Cond: ((name)::text ~~ '%Adaptive zero administration conglomeration%'::text)
   ->  Bitmap Index Scan on bigm_idx_products_name  (cost=0.00..1168.38 rows=50 width=0) (actual time=28.262..28.262 rows=0 loops=1)
         Index Cond: ((name)::text ~~ '%Adaptive zero administration conglomeration%'::text)
 Planning Time: 0.170 ms
 Execution Time: 28.292 ms
(6 rows)
```
### Сравнение запросов с использованием индексов `pg_trgm` и `pg_bigm`

| **Индекс**      | **pg_trgm**                                  | **pg_bigm**                                  |
|-----------------|----------------------------------------------|----------------------------------------------|
| **Тип индекса** | GIN с использованием `gin_trgm_ops`         | GIN с использованием `gin_bigm_ops`          |
| **План запроса** | Bitmap Heap Scan, Bitmap Index Scan (trgm_idx_products_name) | Bitmap Heap Scan, Bitmap Index Scan (bigm_idx_products_name) |
| **Стоимость**   | 832.39..1024.94                             | 1168.39..1360.94                            |
| **Фактическое время** | 82.169 мс                         | 28.262 мс                           |
| **Количество строк** | 0                                        | 0                                            |
| **Время планирования** | 1.582 мс                                 | 0.170 мс                                     |

### Вывод:
1. **Использование индекса**: В обоих случаях используется GIN-индекс для поиска по подстроке, но с разными операторами: для `pg_trgm` используется `trgm_idx_products_name`, а для `pg_bigm` — `bigm_idx_products_name`.
2. **Производительность**: Производительность: Запрос с использованием индекса `pg_bigm` выполняется быстрее (28.262 мс против 82.169 мс у `pg_trgm`), что может свидетельствовать о том, что для данного типа поиска индекс `pg_bigm` работает более эффективно.
3. **Стоимость**: Запрос с `pg_trgm` имеет более низкую стоимость (832.39 против 1168.39 для `pg_bigm`), что также может быть связано с более быстрым поиском при использовании триграмм.

Таким образом, в данном случае индекс `pg_bigm` продемонстрировал лучшие результаты по времени выполнения и стоимости запроса, чем `pg_trgm`.
